### Hackerrank
- **Failed tests:**<br>
  - **WA**: Wrong answer, програмата извежда грешен резултат за дадения тест.<br>
  - **TL**: Time limit exceeded, праграмата работи твърде дълго време за дадения тест.<br>
  - **RE**: Runtime Exception, най-често предизвикан от Segmentation fault - досъпване на памет която не е заделена за вашата програма (пример: A[100] е масив със заделена памет за 100 елемента, но се прави опит за досъпване на 150тия елемент А[150] или -50тия A[-50]).<br>
  - **CE**: Compilation error, програмата не се компилира, ще бъде изведено съобщение описващо точната грешка/и в кода.<br><br>
- **Input and Output:**<br>
  - Не е необходимо да валидирате входните данни.<strong>Constraints</strong> са изпълнени за всички тестове и са там, за да ви дадaт информация отностно колко бързо трябва да решението ви (с каква сложност) и какви типове данни да използвате (double, long long, etc.).<br>
  - Въвеждането и извеждането със cin и cout понякога е бавно и при входни данни с голям размер може да забави програмата ви достатъчно, че да получите TL на някои тестове. Няколко неща които можете на направите, за да укорите работата им:<br>
    - Не използвайте endl когато печатате със cout, тъй като endl изпразва буфера на cout, което е бавна операция. Вместо това ползвайте '\n', по този начин новят ред също ще се запише в буфера и изпразването на буфера ще стане чак когато той се напълни (доста по рядко). Това е проблем основно когато решавате задачи при които трябва да отпечатате много редове.<br>
    - cin.tie(nullptr) - по подразбиране когато използвате cin първо се отпечатва всичко от буфера на cout, тази функция спира тяхната синхронизация и отново изпразването на буфера на cout става по-рядко.<br>
    - ios_base::sync_with_stdio(false) - по-подразбиране потоците от C++ са синхронизирани с потоците от C, тази функция спира тяхната синхронизация и ускорява работата на cin и cout.<br>
    
### Преговор
- **References:**
    <p>

         void someMethod (vector<int> v, int depth) {
             if (depth == v.size()) {
                 return;
             }

             ...

             someMethod(v, depth + 1);
         }  
    </p>
  Сложността на горният метод изглежда линейна O(v.size()), но въсщност е O(v.size() ^ 2), защото в C++ при извикване на функция се копират всичките аргументи - заделя се нова памет и се записват техните стойности в нея. Това отнема толкова време колкото са големи обеките, в примера копираме векора v при всяко извикване на функцията => копираме векотор с размер v.size() при всяко от v.size()-те извиквания на функцията => сложността става О(v.size() ^ 2).
  
    <p>

         void someMethod (vector<int>& v, int depth) {
             if (depth == v.size()) {
                 return;
             }

             ...

             someMethod(v, depth + 1);
         }
    </p>
  Ако подаваме v по референция, тогава той няма да се копира всеки път, а ще използваме оригиналният вектор. Всеки път като правим промени по него, променяме паметта заделена за оригниналнят вектор и съотвено промените ни ще бъдат отразени навсякъде, а не само локално във фукцията. Понеже не копираме вектора всеки път на всяко извикване извършваме v.size() операции по-малко от предния път и сложността на този метод наистина е О(v.size()).<br>
- **Strings:**<br>
  Когато използваме оператора + на string се заделя памет за нов стринг и в нея се записва конкатенацията на двата стринга които събираме, което прави сложността на оператора линейна по размера на събираните стрингове. Ако s1 и s2 са стрингове тогва сложността на s1 + s2 e О(s1.size() + s2.size()).
  <p>

       for (int i = 0; i < s.size(); i++)
           s = s + "a";
       }
  </p>
  Горният изглежда че има сложност О(s.size()), но всъщност сложността му е O(s.size() ^ 2), тъй като копираме стринга s на всяка стъпка от цикъла.
  <br><br>
  За да избегнем копирането можем да използваме два от вградените методи на класа string :
    <ul>
      <li> <strong>s.push_back(char)</strong> - добавя 1 символ (аргумент от тип char) накрая на стринга s</li>
      <li> <strong>s.append(string)</strong> - добавя string накрая на стринга s</li>
    </ul>
  <br>
  <p>

       for (int i = 0; i < s.size(); i++)
           s.push_back('a');
       }
  </p>
  Горният код наистина има линейна сложност О(s.size()).
   
### Complexity
<pre><strong>
-------------------------------------------
|      N <= 10      |        O(N!)        |
-------------------------------------------
|      N <= 20      |        O(2^N)       |
-------------------------------------------
|      N <= 100     |        O(N^4)       |
-------------------------------------------
|      N <= 400     |        O(N^3)       |
-------------------------------------------
|    N <= 10 000    |        O(N^2)       |
-------------------------------------------
|    N <= 200 000   |      O(N log N)     |
-------------------------------------------
|   N <= 1 000 000  |         O(N)        |
-------------------------------------------
|   N > 1 000 000   |    O(log N), O(1)   |
-------------------------------------------
</strong></pre>

### Tasks
  - https://www.hackerrank.com/contests/practice-1-sda/challenges/encoding-password
  - https://www.hackerrank.com/contests/practice-1-sda/challenges/challenge-2196
  - https://www.hackerrank.com/challenges/non-divisible-subset/problem
